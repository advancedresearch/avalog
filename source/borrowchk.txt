// # Borrow Checker
//
// To use this file, save it in your working folder and type:
// `import "borrowchk.txt"`
//
// This formalises a borrow checker with allocation/deallocation on tree structures
// with move and borrow semantics.
//
// Technique is based on paper "Restricted Dual Composition":
// https://github.com/advancedresearch/path_semantics/blob/master/papers-wip2/restricted-dual-composition.pdf
//
// Restricted Dual Composition uses sink/sources semantics over dual objects to make composition more efficient:
//
// - `(c'(X), X)` source: the object `X` needs to be deallocated (generated by allocation)
// - `(X, c'(X))` sink: the object `X` is deallocated
//
// To add types that require cleanup, use e.g. `(c'(X), X) :- X : P, P : string.`
//
// Here is an example of a person `a` named "Carl" that is 18 years old:
// ```
// name : string
// age : nat
// 
// carl : name
// a : person
// 18 : age
// 
// (a, carl)
// (a, 18)
// ```
//
// To move `a`, use e.g. `(a, mov'(b))`.
// You can also move a moved object, e.g. `(b, mov'(c))`.
// Moved objects can be destroyed, e.g. `(c, c'(c))`.
//
// To borrow `a`, use e.g. `(a, ref'(b))`.
// To borrow a mutable `a`, use e.g. `(a, ref_mut'(b))`.
//
// This formalisation only works in a single context,
// and does not check for aliased moves (due to limitations of monotonic solvers).
// To check for aliased moves, a linear solver might be used on the generated output.
//
// Conditional branches, e.g. if-else expressions, must match sink/sources.
//
// Loops must not introduce new sink/sources that are not covered by isomorphisms.
// This means every `(c'(X), X)` must be covered by an `(X, c'(X))` and vice versa.

// Needing only one side of restricted dual composition.
(X, Z) :- (X, Y), (Y, Z), (c'(X), X), X != c'(T).

// Lift `mov`, `ref` and `ref_mut` to preserve composition.
(N'(Y), M'(Z)) :- (Y, M'(Z)), (X, N'(Y)), Y != A'(B), M != c, N != c.

// Seek to clean up everything that has some
// property to be cleaned up.
(c'(X), X) :- X : T, (c'(Y), Y), U(X) = Y.

// If something has been cleaned up and has some
// property to be cleaned up, then the property is cleaned up.
(Y, c'(Y)) :- X : T, (X, c'(X)), (c'(Y), Y), U(X) = Y.

// When cleaning up a moved object, call its destructor.
(mov'(Y), c'(X)) :- (Y, c'(Y)), (X, mov'(Y)).

// Do not allow destroying objects that are borrowed.
amb :- (X, c'(X)), (X, ref'(Y)).
amb :- (X, c'(X)), (X, ref_mut'(Y)).

// Borrow aliasing rules.
amb :- (X, ref_mut'(Y)), (X, ref'(Z)), Y != Z.
amb :- (X, ref_mut'(Y)), (X, ref_mut'(Z)), Y != Z.
